----------------------------------------------------------------------------------------------------------------------------------
2. Add Two Numbers
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.

A:
Keep the carry over and indexing, should be easy


----------------------------------------------------------------------------------------------------------------------------------
8. String to Integer (atoi)
Implement atoi to convert a string to an integer.

Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.

Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.

A:
quite useless test

just to notice for python we can use 
(1) .isdigit for character 
(2) ord() gives the number representation of a single length character


----------------------------------------------------------------------------------------------------------------------------------
11. Container With Most Water

Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.


A:
Important to realize that the two edges we pick are bounded by the smaller one
We use the two pointer case algorithm
Start with the boundary ones, this will give the largest width
Then we can remove the shorter edge and move the pointer towards the other
This is because we already know that we don't have to consider it for the current width, which is the largest it could achieve

----------------------------------------------------------------------------------------------------------------------------------
33. Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm's runtime complexity must be in the order of O(log n).


A:
Binary search. Since we need to return -1 if no element found
Pay attention to corner cases for length 0 and 1
Forum also showed that while loop is better than recursion with function


----------------------------------------------------------------------------------------------------------------------------------
39. Combination Sum

Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.

The same repeated number may be chosen from C unlimited number of times.

Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
For example, given candidate set [2, 3, 6, 7] and target 7, 
A solution set is: 
[
  [7],
  [2, 2, 3]
]


A:
Use DP
Key is to realize that to avoid duplicates, we need to maintain an
order strucutre in the constructed sequence 
If we sort the candidates and constatnly compare it to the last element 
of the current accumulated list, then naturally avoid duplicates




----------------------------------------------------------------------------------------------------------------------------------
40. Combination Sum II
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
'''


A:
need sorted arrays to improve the running time
use DP recurse on the smaller subset to find the good sum
use set to return no duplicates events


----------------------------------------------------------------------------------------------------------------------------------
48. Rotate Image
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Note:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

A:

key to realize
x1, y1 = 0, i
x2, y2 = i, size-1
x3, y3 = size-x1-1, size-y1-1
x4, y4 = size-x2-1, size-y2-1
and be careful that 



----------------------------------------------------------------------------------------------------------------------------------
54. Spiral Matrix
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

For example,
Given the following matrix:

[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
You should return [1,2,3,6,9,8,7,4,5].

A:
Same as the sprial matrix II problem. 
Loop over to peel off layers. 
Make sure do the right thing when encounter m ==1, n==1 cases 



----------------------------------------------------------------------------------------------------------------------------------
56. Merge Intervals
Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].

A:
sort first with lambda function
then just merge 



----------------------------------------------------------------------------------------------------------------------------------
59. Spiral Matrix II

Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

For example,
Given n = 3,

You should return the following matrix:

[
     [ 1, 2, 3 ],
     [ 8, 9, 4 ],
     [ 7, 6, 5 ]
    ]


A:
brute force O(N) solution. Same recursion as the rotation problem


----------------------------------------------------------------------------------------------------------------------------------
62. Unique Paths
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
How many possible unique paths are there?

A:
return fact(m+n-2)/( fact(m-1)*fact(n-1)  )
or just DP


----------------------------------------------------------------------------------------------------------------------------------
63. Unique Paths II
Follow up for "Unique Paths":
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
For example,
There is one obstacle in the middle of a 3x3 grid as illustrated below.
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
The total number of unique paths is 2.
Note: m and n will be at most 100.


A:
use DP, essential to realize that we rely on the bounds [x,0] and [0,y] to do induction. 
path [i][j]= path[i-1][j]+path[i][j-1]
Hence need to intialize them to be 0 if there is an obstacle behind. 



----------------------------------------------------------------------------------------------------------------------------------
64. Minimum Path Sum
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example 1:
[[1,3,1],
 [1,5,1],
  [4,2,1]]

Given the above grid map, return 7. 

A:
Use DP, keep table of the min up to [i,j]


----------------------------------------------------------------------------------------------------------------------------------
67. Add Binary
Given two binary strings, return their sum (also a binary string).
For example,
a = "11"
b = "1"
Return "100".


A:
one pass; keep track of the carry over 



----------------------------------------------------------------------------------------------------------------------------------
73. Set Matrix Zeroes

Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Input: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]


A:
Note that these are integers marking them with -1 is not good.
Instead mark the ones going to be flipped as a character or something else then we can solve in place

Another solution from online is to use the first column and first row as storage space



----------------------------------------------------------------------------------------------------------------------------------
74. Search a 2D Matrix
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true


A:
use binary search and modulo to find the indicies        



----------------------------------------------------------------------------------------------------------------------------------
75. Sort Colors

Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
Note:
You are not suppose to use the library's sort function for this problem.

A:
many ways to approach; with O(n) space we can just count and expand out the list
with O(1) space:
     first trial, two pass, loop through the list swap first 0's to the begining, then swap 2's to the end
     second approach: keep to counters of boundaries i, j for 0 and 1; loop over and fill elements according to boundaries;


----------------------------------------------------------------------------------------------------------------------------------
78. Subsets

Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.


A:
first put the intergers into set
then loop over elements and create power set by recursion



----------------------------------------------------------------------------------------------------------------------------------
80. Remove Duplicates from Sorted Array II

Follow up for "Remove Duplicates":
What if duplicates are allowed at most twice?

For example,
Given sorted array nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length.


A:
Best solution is O(n) time complexity and O(1) space
if the current elment is larger than the nums[i-2], then we should increase the count and move this element ahead
otherwise, it's a duplicate and needs to be removed by elements later



----------------------------------------------------------------------------------------------------------------------------------
86. Partition List

Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
You should preserve the original relative order of the nodes in each of the two partitions.
For example,
Given 1->4->3->2->5->2 and x = 3,
return 1->2->2->4->3->5.


A:
Purely manipulation of linked list. 

Initialize a header and a moving list for both left and right sets with dummy node
while the moving list moves forward, the header stays at the original 
value and can be used to link two sets together

left.next = h2.next # links two sets
return h1.next get rid off the starting dummy node



----------------------------------------------------------------------------------------------------------------------------------
90. Subsets II
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

For example,
If nums = [1,2,2], a solution is:

[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]


A:
same as the subset problem. But note here that we would need to output without duplicates.
so build a dictionary first and then append based on the counts of each element



----------------------------------------------------------------------------------------------------------------------------------
120. Triangle
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
 

The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).


A:
We can solve in-place with DP. So O(MN) time and O(1) space


----------------------------------------------------------------------------------------------------------------------------------
142. Linked List Cycle II
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up:
Can you solve it without using extra space?


A:
tortoise and hare again
note that we can nest the two while.


----------------------------------------------------------------------------------------------------------------------------------
152. Maximum Product Subarray
Find the contiguous subarray within an array (containing at least one number) which has the largest product.

For example, given the array [2,3,-2,4],
the contiguous subarray [2,3] has the largest product = 6.

A:
modification of Kadane’s algorithm for largest sum

If we don't have negative values, it's obvious that we can just use Kadane's directly
i.e. define a variable localMax(i) to be the largest product up to i'th position
where localMax(i+1) = Max(localMax(i), num[i+1])
And we also keep a global largest value to be globalMax 

If we have the negative values, then we need to take care of the negative values as well
so we keep track of a minimum



----------------------------------------------------------------------------------------------------------------------------------
153. Find Minimum in Rotated Sorted Array

Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Find the minimum element.
You may assume no duplicate exists in the array.


A:
No duplicates we can use binary search.
Be carefuly with the length of the array. We could start with length 1 which we should return directly		                    


----------------------------------------------------------------------------------------------------------------------------------
216. Combination Sum III
Find all possible combinations of k numbers that add up to a number n, g
iven that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

A:
use recursion
Note:
(1) Every time pass in one list to the next step and if satisfies the requirement add to the solution; Don't over think about the problem
(2) Shrink the tree size for each search. 
(3) Note carefully about the k value 


----------------------------------------------------------------------------------------------------------------------------------
238. Product of Array Except Self
Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
Solve it without division and in O(n).
For example, given [1,2,3,4], return [24,12,8,6].

A:
two passes, first get the products for list_1= [ a2, a2a3, a2a3, ..., a2a3...an]
remember to shift the products


----------------------------------------------------------------------------------------------------------------------------------
244. Shortest Word Distance II
This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?

Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.

For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Given word1 = “coding”, word2 = “practice”, return 3.
Given word1 = "makes", word2 = "coding", return 1.


A:
if we don't want to count the dictionary building time, and only count access time, we should pre-build dict for all pairs then access takes O(1)
otherwise, build location ditionary and given a pair loop through the locations and calculate the difference. This would go as O(m+n)


----------------------------------------------------------------------------------------------------------------------------------
245. Shortest Word Distance III
This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.
Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.
word1 and word2 may be the same and they represent two individual words in the list.
For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
Given word1 = “makes”, word2 = “coding”, return 1.
Given word1 = "makes", word2 = "makes", return 3.

A:
Cache the previous seen word1 or word2
if word 1 = curr: and cache == word2, check length
elif word 2 = curr: and cache == word 1, check length



----------------------------------------------------------------------------------------------------------------------------------
259. 3Sum Smaller
Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.
For example, given nums = [-2, 0, 1, 3], and target = 2.
Return 2. Because there are two triplets which sums are less than 2:

A:
Sort takes O(nlogn), so let's do it
Then it's a matter of increment i, j. Same problem as the three segements for triangle
Do a reversed scan of k




----------------------------------------------------------------------------------------------------------------------------------
277. Find the Celebrity
Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).
You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.
Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.


A:
Two cases:
(1) if the celebrity exists, since there is only one, we need only one loop to find it:
we loop over all people and ask if the person knows the next.
celebrity does not know anyone else, so the pointer will stop at him
(2) if the celebrity does not exit, then we need to check for the person we get from (1)
(a) if he happens to know anyone else and (b) if everyone knows him


----------------------------------------------------------------------------------------------------------------------------------
280. Wiggle Sort
Given an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3]....
For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].


A:
initial trial, very shitty solution; Sort first then combine
second way:
note that we can do in O(n) time
if we are sorting less, i.e. a[i]<a[i+1], then the next sorting greater will make the swap iff a[i+2]>= a[i+1] and hence the currrent swap is still valid


----------------------------------------------------------------------------------------------------------------------------------
287. Find the Duplicate Number
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.

Note:
You must not modify the array (assume the array is read only).
You must use only constant, O(1) extra space.
Your runtime complexity should be less than O(n2).
There is only one duplicate number in the array, but it could be repeated more than once.


A:
If no constraints
(1) sort then loop, easy, space complexity is O(1) or O(n) while time complexity is O(nlogn)
(2) use set to store visted items, space complexity is O(n) and time complexity is O(n)
        
        
To show we must have duplicate is easy (pigeon hole)
Since 0 is an index and 0 is not in the range, we hence must have a cycle.         
        
use Floyd's tortoise and hare algorithm for circle detection gives O(n) run time and O(1) storage
        
Algorithm: 
        
Phase 1: for a sequence entering cycles from element x_m and length of cycle being l, 
we must have for i=k*l>=m, x_i = x_2i. Therefore we just need to keep track of two pointers, one moves forward
one step and the other moves forward two steps at a time. Once they meet we know that we are in a random point
n on the cycle
        
Phase 2: to find the enterting point of the cycle. We reset tortoise to point 0 and keep hare at n
The distance between them is constantly 2l if we now move both of them at same speed. 
By the time tortoise reachs m, hare will be at m+2l. Therefore we find the entering point. 



----------------------------------------------------------------------------------------------------------------------------------
289. Game of Life

According to the Wikipedia's article: "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970."

Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

Any live cell with fewer than two live neighbors dies, as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population..
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
Write a function to compute the next state (after one update) of the board given its current state.

Follow up: 
Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.
In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?


A:
so we need four coding basically:
0  = dead->dead
1  = live->live
2  = dead->live
3  = live->dead        

Then use list comprehension for better representation of the neighbors.
We can include the point itself than subtract it



----------------------------------------------------------------------------------------------------------------------------------
328. Odd Even Linked List
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example:
Given 1->2->3->4->5->NULL,
return 1->3->5->2->4->NULL.

Note:
The relative order inside both the even and odd groups should remain as it was in the input. 
The first node is considered odd, the second node even and so on ...

A:
Linked list manipulation. Note it's about the position polarity not the value polarity
just have to be very careful what's being linked and not



----------------------------------------------------------------------------------------------------------------------------------
357. Count Numbers with Unique Digits
Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x < 10n.
Example:
Given n = 2, return 91. (The answer should be the total numbers in the range of 0 ≤ x < 100, excluding [11,22,33,44,55,66,77,88,99])

A:
easy counting for n = 0, return 1
for n>=1, the first digits takes 9 values the rest takes 9, 8, 7 etc. 


----------------------------------------------------------------------------------------------------------------------------------
370. Range Addition
Assume you have an array of length n initialized with all 0's and are given k update operations.
Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.
Return the modified array after all k operations were executed.


A:
could use naive approach but takes O(k*n) 
two pass cumulative sum : O(k+n)
for an array that has  A[start] += inc and A[end+1] -= inc
second path keep a sum and fill in the new array with the cumulative sum        



----------------------------------------------------------------------------------------------------------------------------------
380. Insert Delete GetRandom O(1)

Design a data structure that supports all following operations in average O(1) time.
insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.

A:
Key is the getRandom operation. For set we can already do insert and delete with O(1) time.
Random we need indexing and hence need a list for this

A few notes:
python list pop takes O(1), append takes O(1), del takes O(n)
python dic look up O(1), insert O(1), del O(1), make list O(n)


----------------------------------------------------------------------------------------------------------------------------------
423. Reconstruct Original Digits from English
Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.

Note:
Input contains only lowercase English letters.
Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.
Input length is less than 50,000.


A:
important thing is to notice we can calculate the numbers based on the appearances of characters


----------------------------------------------------------------------------------------------------------------------------------
422. Find All Duplicates in an Array
Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements that appear twice in this array.
Could you do it without extra space and in O(n) runtime?

A:
Important to realize that the integers are always less than the size of the array, 
Hence we can index them to be between 0 and n-1
Then we apply polarity to the existing array



----------------------------------------------------------------------------------------------------------------------------------
490. The Maze

There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.

The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.


A:
equivalent to finding a connected components, just dfs
preprocess to expand maze to include boundary
be very careful with the statement. the ball can be rolled until it sees an obstacle.
one thought is that for rolling based boundary determination, better to use while and avoid tough indexing


----------------------------------------------------------------------------------------------------------------------------------
495. Teemo Attacking
In LOL world, there is a hero called Teemo and his attacking can make his enemy Ashe be in poisoned condition. Now, given the Teemos attacking ascending time series towards Ashe and the poisoning time duration per Teemos attacking, you need to output the total time that Ashe is in poisoned condition.
You may assume that Teemo attacks at the very beginning of a specific time point, and makes Ashe be in poisoned condition immediately.

A:
this is rather easy



----------------------------------------------------------------------------------------------------------------------------------
523. Continuous Subarray Sum
Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.

A:
looks easy but has a lot  corner cases

to deal with k==0, we need to count number of continuous 0's
to deal with k!=0, remember of check continuos 0's as well

in general use the same idea as keep sum up to i, and check all the remainders of A[:j] for j<i. 
If remainder[j] == remainder[i], then we found a sum. 

Important to initialize the map to have 1 count for remainder 0



----------------------------------------------------------------------------------------------------------------------------------
526. Beautiful arrangements
Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:

The number at the ith position is divisible by i.
i is divisible by the number at the ith position.
Now given N, how many beautiful arrangements can you construct?

A:
constructive DP with memorization
search for permutations which would work

tuple is immutable hence hashable
set is mutable hence not hashable !!!!!
enumerate gives both index and object


----------------------------------------------------------------------------------------------------------------------------------
531. Lonely Pixel I

Given a picture consisting of black and white pixels, find the number of black lonely pixels.
The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively.
A black lonely pixel is character 'B' that located at a specific position where the same row and same column don't have any other black pixels.

A:
key points are that we cannot do better than O(mn). Need to look through cols and rows for sure.
Then keep dicts for both cols and rows to count the number of 'B' in each row and col
Then output the min of row and cols with having 1 "B"


----------------------------------------------------------------------------------------------------------------------------------
533. Lonely Pixel II
Given a picture consisting of black and white pixels, and a positive integer N, find the number of black pixels located at some specific row R and column C that align with all the following rules:

Row R and column C both contain exactly N black pixels.
For all rows that have a black pixel at column C, they should be exactly the same as row R
The picture is represented by a 2D char array consisting of 'B' and 'W', which means black and white pixels respectively.


A:
since we need the exact patterns of the rows, 
we need to use hash map for the patterns which satsfy the row count requirement
for the full loop we also store all the column counts

then loop through all the patterns and see which columns satisfy the N counts
for each column satisfying the requirement count += N



----------------------------------------------------------------------------------------------------------------------------------
541. Reverse String II
Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.

A:
same thought as reverse string, just need to discuss different cases. 


----------------------------------------------------------------------------------------------------------------------------------
560. Subarray Sum Equals K
Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

A:
Two ways to do:
(1) is to keep the cumulative sum and loop over all sub arrays, taking O(n^2) time and O(1) space
(2) is to use hash map to record the sum of elements up to nums[i]
    we can find subarrays with sum k by checking nums[i]-nums[j]==k for j<i



----------------------------------------------------------------------------------------------------------------------------------
562. Longest Line of Consecutive One in Matrix

Given a 01 matrix M, find the longest line of consecutive one in the matrix. The line could be horizontal, vertical, diagonal or anti-diagonal.

Input:
[[0,1,1,0],
 [0,1,1,0],
 [0,0,0,1]]
Output: 3


A:
Use DP. Keep table of four elements. 
One for continuous row up to [i,j]. One for col, one for diag and one for anti-diag
My sol could be simplified somewhat more. No need to initialize the first row


----------------------------------------------------------------------------------------------------------------------------------
565. zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } subjected to the rule below.
Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.

A:
use dfs nothing is fancy


----------------------------------------------------------------------------------------------------------------------------------
611. Valid Triangle Number
Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.
Input: [2,2,3,4]
Output: 3
Explanation:
Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3


A:
impossible to do better than O(n^2)
so just sort first 
then we need to satisfy one constraint which is a+b>c. 
start scanning i,j,k with j= i+1 and k=i+2. Stop if nums_[k] cannot satisfy the requirement there. 
for a particular pair of i,j, we have k-j-1 combinations
need to really pay attention to case where i, j =0. So always start scanning with k at least as large as j+1



----------------------------------------------------------------------------------------------------------------------------------
621. Task Scheduler
Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.
However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.
You need to return the least number of intervals the CPU will take to finish all the given tasks.

Input: tasks = ["A","A","A","B","B","B"], n = 2
Output: 8
Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.


A:
key is that we should schedule the most frequent task in remaining set 
whenever it has passed the cooling period
as we don't need to ouput the actual sequence
we just need to keep the number of tasks
(1) use max heap to keep track of the next biggest one
(2) segment the sequence into periods of length n+1, the first task will be the one with biggest remaining counts
    then need to decrease the first [1:n+1] task counts by 1 as well            
(3) python does not have max heap. But can use min heap and negative values to work it out         




----------------------------------------------------------------------------------------------------------------------------------
667. Nice Array
Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:
Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.

If there are multiple answers, print any of them.

A:
for 1 to n-k-1 we don't do anything
for n-k+1 to n, we have [n-k, n, n-k+1, n-1, ...], we get difference k, k-1, k-2, to 1 etc. 



----------------------------------------------------------------------------------------------------------------------------------
670. Maximum Swap
Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.

Input: 2736
Output: 7236
Explanation: Swap the number 2 and the number 7.


A:
O(n) time solution, loop over once to record the Maxium from [i:end]
and then loop again to swap for the current event with the maximum in the rest of the 
array with the largest index



----------------------------------------------------------------------------------------------------------------------------------
713. Subarray Product Less Than K
Your are given an array of positive integers nums.
Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.

A:
if array[start:end] works then anything within the array works
every time increment end +1 and check the cumulative product
if product <K, count += (end-start)
else: move start to start +1 and check again


----------------------------------------------------------------------------------------------------------------------------------
714. Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.
You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)
Return the maximum profit you can make.

A:
Need O(N) time
keep three things signal, sell and buy

loop through the array:
   ####be super careful about the update order

   if current price >sell and current price > sell+buy:
     update sell
        
   if buy>sell+fee:
     start to look forward and see if we have another drop back of price with p+fee<buy
        
   if current price <buy:
     update buy


----------------------------------------------------------------------------------------------------------------------------------
718. Maximum Length of Repeated Subarray
Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.

Example 1:
Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].


A:
use DP in this case        
Basically uses a table to keep track of the 
longest common suffixes up to [i,j]
similar to the unique path problem



----------------------------------------------------------------------------------------------------------------------------------
723. Candy Crush
This question is about implementing a basic elimination algorithm for Candy Crush.

Given a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player's move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:

If three or more candies of the same type are adjacent vertically or horizontally, "crush" them all at the same time - these positions become empty.
After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.)
After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps.
If there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.
You need to perform the above rules until the board becomes stable, then return the current board.

A:
Algorithm goes into two parts:
(1) First mark all the points which can be crashed
    Have to loop through all colums and rows and find three consecutive pixels

(2) Second apply the gravity:
    This can be done using the same algorithm as Dutch Flag color partition i.e. keep the partition pointer 



----------------------------------------------------------------------------------------------------------------------------------
729. My Calendar I
Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.
Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.
A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)
For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.
Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)

A:
use BST to do the work. 
Just rememeber the nodes could contain more things than just one number



----------------------------------------------------------------------------------------------------------------------------------
731. My Calendar II
Implement a MyCalendarTwo class to store your events. A new event can be added if adding the event will not cause a triple booking.
Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.
A triple booking happens when three events have some non-empty intersection (ie., there is some time that is common to all 3 events.)
For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.
Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)


A:
The problem seems easy but has a lot tricks
Pay attention to the details. It says no two conflict booking. It's ok to have C overlaps with A and B, while A and B do not overlap
Can only solve it in O(n^2) haven't seen better answers
Idea is to keep track of the current overlaps and the current calendar. 



----------------------------------------------------------------------------------------------------------------------------------
769. Max Chunks To Make Sorted
Given an array arr that is a permutation of [0, 1, ..., arr.length - 1], we split the array into some number of "chunks" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.

What is the most number of chunks we could have made?


Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.


A:
go through the list once, 
we use induction, 
a subarray can be sorted together iff max(subarray) == len(subarray)
otherwise some larger element from later part of the array is mixed in and we will have to bring that to the end. 



----------------------------------------------------------------------------------------------------------------------------------
792. Number of Matching Subsequences

Given string S and a dictionary of words words, find the number of words[i] that is a subsequence of S.


Example :
Input: 
S = "abcde"
words = ["a", "bb", "acd", "ace"]
Output: 3
Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace".

Note:

All words in words and S will only consists of lowercase letters.
The length of S will be in the range of [1, 50000].
The length of words will be in the range of [1, 5000].
The length of words[i] will be in the range of [1, 50].

A:
keep a dictionary for words and which letter they are waiting for        
then if we see the needed first word, elimnate that first letter 
and re-organize the dictionary
If the word has length one and meet its needed letter then we can 
increment the counter



----------------------------------------------------------------------------------------------------------------------------------
795. Number of Subarrays with Bounded Maximum

We are given an array A of positive integers, and two positive integers L and R (L <= R).
Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R.
Example :
Input: 
A = [2, 1, 4, 3]
L = 2
R = 3
Output: 3
Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].

Note:
L, R  and A[i] will be an integer in the range [0, 10^9].
The length of A will be in the range of [1, 50000].


A:
Mis-understood the problem at first hand
We keep expanding the array with all elements <=R
We should notice that for any element >R, the counting of consecutive subarrays will stop
For a given subarray M, if an element is less than L, it could be combined with some near by element which is in between L and R
Therefore, we should count the number of continuous subarrays K with less than L within each subarray that only contains 
elements less than R. Then subtract K from the number of continuos sybarrays in M. 
